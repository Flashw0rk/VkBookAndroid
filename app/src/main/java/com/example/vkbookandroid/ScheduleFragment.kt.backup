package com.example.vkbookandroid

import android.content.Context
import android.graphics.Color
import android.graphics.drawable.GradientDrawable
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.*
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.GsonBuilder
import com.google.gson.reflect.TypeToken
import java.io.File
import java.util.*

/**
 * Данные заметки для дня
 */
data class DayNote(
    val comment: String = "",
    val hasReminder: Boolean = false,
    val reminderHour: Int = 9,
    val reminderMinute: Int = 0,
    val isImportant: Boolean = false,
    val photoPath: String? = null
)

/**
 * Фрагмент для отображения графика смен на год
 */
class ScheduleFragment : Fragment() {
    
    private lateinit var calendarRecyclerView: RecyclerView
    private lateinit var horizontalScrollView: HorizontalScrollView
    private lateinit var yearTextView: TextView
    private lateinit var btnPrevYear: Button
    private lateinit var btnNextYear: Button
    private lateinit var btnToday: Button
    
    private var currentYear: Int = Calendar.getInstance().get(Calendar.YEAR)
    private lateinit var scheduleAdapter: ScheduleCalendarAdapter
    
    // Кэш предрасчитанных сдвигов месяцев: Map<"Year-Month", Shift>
    private val monthShiftCache = mutableMapOf<String, Int>()
    
    // Базовый паттерн смен (40 элементов для непрерывного цикла)
    private val baseShiftPattern = arrayOf(
        "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1",
        "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1"
    )
    
    // Статичные паттерны для каждой смены (36 ячеек без пустых) - ТОЧНЫЕ последовательности
    private val shiftPatterns = arrayOf(
        // Смена 1: 3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4 (36 элементов)
        arrayOf("3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4"),
        
        // Смена 2: 4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3
        arrayOf("4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3"),
        
        // Смена 3: 2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1
        arrayOf("2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1"),
        
        // Смена 4: 1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2
        arrayOf("1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2"),
        
        // Смена 5: Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх,3,2,4,1,Вх,4,1,3,2,Вх
        arrayOf("Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх")
    )
    private val shiftNames = arrayOf("Смена 1", "Смена 2", "Смена 3", "Смена 4", "Смена 5")
    
    // Данные для пометок
    private val dayNotes = mutableMapOf<String, DayNote>()
    
    // Выбранный день для подсветки столбика
    private var selectedDayInMonth: Int = -1
    private var selectedMonthIndex: Int = -1
    
    // Сегодняшняя дата для автоматического выделения
    private val todayCalendar = Calendar.getInstance()
    private val todayYear: Int = todayCalendar.get(Calendar.YEAR)
    private val todayMonth: Int = todayCalendar.get(Calendar.MONTH)
    private val todayDay: Int = todayCalendar.get(Calendar.DAY_OF_MONTH)
    
    companion object {
        private const val TAG = "ScheduleFragment"
        private const val NOTES_FILE = "schedule_notes.json"
    }
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.fragment_schedule, container, false)
        
        // Инициализация views
        calendarRecyclerView = view.findViewById(R.id.calendarRecyclerView)
        horizontalScrollView = view.findViewById(R.id.horizontalScrollView)
        yearTextView = view.findViewById(R.id.yearTextView)
        btnPrevYear = view.findViewById(R.id.btnPrevYear)
        btnNextYear = view.findViewById(R.id.btnNextYear)
        btnToday = view.findViewById(R.id.btnToday)
        
        setupViews()
        setupRecyclerView()
        loadDayNotes()
        updateYearDisplay()
        generateScheduleData()
        
        // Центрируем на текущей дате при открытии
        view.post { scrollToToday() }
        
        return view
    }
    
    private fun setupViews() {
        btnPrevYear.setOnClickListener {
            currentYear--
            updateYearDisplay()
            generateScheduleData()
        }
        
        btnNextYear.setOnClickListener {
            currentYear++
            updateYearDisplay()
            generateScheduleData()
        }
        
        btnToday.setOnClickListener {
            currentYear = Calendar.getInstance().get(Calendar.YEAR)
            updateYearDisplay()
            generateScheduleData()
            // Выделяем сегодняшний столбец
            selectedDayInMonth = todayDay
            selectedMonthIndex = todayMonth
            scheduleAdapter.setSelectedDay(selectedDayInMonth, selectedMonthIndex)
            scheduleAdapter.notifyDataSetChanged()
            view?.post { scrollToToday() }
        }
    }
    
    private fun setupRecyclerView() {
        scheduleAdapter = ScheduleCalendarAdapter(
            requireContext(),
            dayNotes,
            ::onDayClick,
            ::calculateMonthShift,  // Передаем функцию с кэшем из фрагмента
            ::getAdjustedShiftForDisplay  // Передаем функцию корректировки сдвига
        )
        calendarRecyclerView.layoutManager = LinearLayoutManager(context)
        calendarRecyclerView.adapter = scheduleAdapter
    }
    
    private fun updateYearDisplay() {
        yearTextView.text = currentYear.toString()
    }
    
    /**
     * Корректирует сдвиг месяца так, чтобы все дни поместились в 36 ячеек.
     * Сохраняет соответствие с паттерном смен, сдвигая весь календарь и график синхронно.
     * 
     * @param year Год
     * @param monthIndex Индекс месяца (0-11)
     * @param daysInMonth Количество дней в месяце
     * @return Скорректированный сдвиг (0-5 для 31-дневных месяцев)
     */
    private fun getAdjustedShiftForDisplay(year: Int, monthIndex: Int, daysInMonth: Int): Int {
        val calculatedShift = calculateMonthShift(year, monthIndex)
        val patternValue = calculatedShift % 10 // Значение 0-9 в базовом паттерне (10 элементов)
        
        // Максимальная безопасная позиция = 36 - количество дней в месяце
        // Для 31 дня: макс позиция = 5 (5 + 31 = 36)
        // Для 30 дней: макс позиция = 6 (6 + 30 = 36)
        // Для 29 дней: макс позиция = 7 (7 + 29 = 36)
        // Для 28 дней: макс позиция = 8 (8 + 28 = 36)
        val maxSafePosition = 36 - daysInMonth
        
        // ИСПРАВЛЕННАЯ ЛОГИКА: Проверяем patternValue напрямую
        if (patternValue + daysInMonth <= 36) {
            // Патерн помещается - используем его
            Log.d(TAG, "Год $year, месяц $monthIndex: calculatedShift=$calculatedShift, patternValue=$patternValue помещается (дней=$daysInMonth)")
            return patternValue
        }
        
        // Патерн НЕ помещается - ищем позицию в предыдущих циклах
        // Возможные позиции: patternValue - 10, patternValue - 20, patternValue - 30, ...
        var adjustedPosition = patternValue
        while (adjustedPosition > maxSafePosition) {
            adjustedPosition -= 10
            if (adjustedPosition < 0) {
                // Не нашли подходящую позицию, используем 0 (или maxSafePosition, если 0 не помещается)
                val fallback = if (daysInMonth <= 36) 0 else maxSafePosition.coerceAtLeast(0)
                Log.w(TAG, "Год $year, месяц $monthIndex: НЕ НАШЛИ позицию! patternValue=$patternValue, используем fallback=$fallback")
                return fallback
            }
        }
        
        // Нашли подходящую позицию
        Log.d(TAG, "Год $year, месяц $monthIndex: calculatedShift=$calculatedShift, patternValue=$patternValue, adjustedShift=$adjustedPosition (дней=$daysInMonth)")
        return adjustedPosition
    }
    
    private fun generateScheduleData() {
        val scheduleData = mutableListOf<ScheduleRow>()
        
        val months = arrayOf(
            "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь",
            "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"
        )
        
        val daysInMonths = intArrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
        if (isLeapYear(currentYear)) {
            daysInMonths[1] = 29
        }
        
        // ВАЖНО: Вычисляем ЕДИНЫЙ сдвиг для ВСЕГО года (на основе января)
        val januaryCalculatedShift = calculateMonthShift(currentYear, 0)
        val januaryAdjustedShift = getAdjustedShiftForDisplay(currentYear, 0, daysInMonths[0])
        val yearShiftOffset = januaryCalculatedShift - januaryAdjustedShift
        
        Log.d(TAG, "═══ Год $currentYear - Расчет календаря ═══")
        Log.d(TAG, "Январь: calculated=$januaryCalculatedShift, adjusted=$januaryAdjustedShift")
        Log.d(TAG, "Сдвиг года (yearShiftOffset): $yearShiftOffset")
        
        // Генерируем строки месяцев с фиксированной шириной 36 ячеек
        months.forEachIndexed { monthIndex, monthName ->
            val days = (1..daysInMonths[monthIndex]).toList()
            
            // Вычисляем количество дней от января (для позиционирования в окне)
            val daysFromJanuary = (0 until monthIndex).sumOf { daysInMonths[it] }
            
            // Позиция месяца в окне = позиция января + дни от января
            // График статичный, календарь последовательный от позиции јануари
            val calculatedShift = calculateMonthShift(currentYear, monthIndex)
            val adjustedShift = calculatedShift - yearShiftOffset
            
            Log.d(TAG, "Месяц $monthName: calculated=$calculatedShift, adjusted=$adjustedShift (сдвиг -$yearShiftOffset)")
            
            // Проверка: если месяц не помещается в 36 ячеек
            val safeAdjustedShift = if (adjustedShift + daysInMonths[monthIndex] > 36) {
                Log.w(TAG, "ВНИМАНИЕ: $monthName на позиции $adjustedShift + ${daysInMonths[monthIndex]} дней = ${adjustedShift + daysInMonths[monthIndex]} > 36!")
                
                // Сдвигаем месяц влево на 10 позиций (один цикл базового паттерна)
                val shifted = (adjustedShift - 10 + 36) % 36
                
                if (shifted + daysInMonths[monthIndex] <= 36) {
                    Log.d(TAG, "  ✅ Сдвиг -10: позиция $shifted помещается")
                    shifted
            } else {
                    // Еще сдвиг
                    val shifted2 = (shifted - 10 + 36) % 36
                    if (shifted2 + daysInMonths[monthIndex] <= 36) {
                        Log.d(TAG, "  ✅ Сдвиг -20: позиция $shifted2 помещается")
                        shifted2
                    } else {
                        // Еще сдвиг
                        val shifted3 = (shifted2 - 10 + 36) % 36
                        if (shifted3 + daysInMonths[monthIndex] <= 36) {
                            Log.d(TAG, "  ✅ Сдвиг -30: позиция $shifted3 помещается")
                            shifted3
                        } else {
                            // Крайний fallback: используем 0
                            Log.w(TAG, "  ⚠️ Крайний случай: используем позицию 0")
                            0
                        }
                    }
                }
            } else {
                adjustedShift
            }
            
            // Создаем список дней - числа идут от меньшего к большему
            val displayDays = mutableListOf<String>()
            
            // Добавляем пустые ячейки в начале (скорректированный сдвиг)
            repeat(safeAdjustedShift) { displayDays.add("") }
            
            // Добавляем дни месяца по порядку (1, 2, 3, ..., 31)
            days.forEach { day -> displayDays.add(day.toString()) }
            
            // Добиваем до 36 ячеек пустыми ячейками в конце
            while (displayDays.size < 36) {
                displayDays.add("")
            }
            
            // Обрезаем до 36 ячеек если больше
            val finalDays = displayDays.take(36)
            
            scheduleData.add(ScheduleRow(monthName, finalDays, isMonthRow = true, monthIndex = monthIndex, year = currentYear))
        }
        
        // ПРОВЕРКА ЦЕЛОСТНОСТИ: все месяцы должны иметь правильное количество дней
        Log.d(TAG, "═══ Проверка целостности календаря ═══")
        var allValid = true
        months.forEachIndexed { monthIndex, monthName ->
            val row = scheduleData[monthIndex]
            val nonEmptyDays = row.days.count { it.toString().isNotEmpty() && it.toString().toIntOrNull() != null }
            val expectedDays = daysInMonths[monthIndex]
            
            if (nonEmptyDays != expectedDays) {
                Log.e(TAG, "❌ ОШИБКА: $monthName имеет $nonEmptyDays дней вместо $expectedDays!")
                allValid = false
            } else {
                Log.d(TAG, "✅ $monthName: $nonEmptyDays дней (ожидается $expectedDays)")
            }
        }
        
        if (allValid) {
            Log.d(TAG, "✅ Все месяцы валидны!")
        } else {
            Log.e(TAG, "❌ ОБНАРУЖЕНЫ ОШИБКИ В КАЛЕНДАРЕ!")
        }
        
        // Добавляем строки смен - СДВИГАЕМ график на yearShiftOffset
        // ВАЖНО: График двигается вместе с календарем!
        // yearShiftOffset показывает, на сколько нужно сдвинуть график влево
        
        Log.d(TAG, "═══ Год $currentYear - График смен (сдвиг на $yearShiftOffset) ═══")
        
        repeat(5) { shiftIndex ->
            val pattern = shiftPatterns[shiftIndex]
            
            // ПРАВИЛЬНАЯ ЛОГИКА: Сдвигаем график на yearShiftOffset
            val shiftedPattern = if (yearShiftOffset == 0) {
                // Сдвига нет - график как есть
                pattern.toList()
            } else {
                // Создаем циклический паттерн (72 элемента)
                val extendedPattern = pattern.toList() + pattern.toList()
                // Берем 36 элементов, начиная с позиции yearShiftOffset
                extendedPattern.subList(yearShiftOffset, yearShiftOffset + 36)
            }
            
            Log.d(TAG, "Смена ${shiftIndex + 1}: сдвиг=$yearShiftOffset, начало=${shiftedPattern.take(5)}")
            
            scheduleData.add(
                ScheduleRow(
                    shiftNames[shiftIndex],
                    shiftedPattern,
                    isMonthRow = false,
                    shiftIndex = shiftIndex
                )
            )
        }
        
        scheduleAdapter.updateData(scheduleData)
        
        // Автоматически выделяем сегодняшний столбец если это текущий год
        if (currentYear == todayYear) {
            selectedDayInMonth = todayDay
            selectedMonthIndex = todayMonth
            scheduleAdapter.setSelectedDay(selectedDayInMonth, selectedMonthIndex)
            scheduleAdapter.notifyDataSetChanged()
            Log.d(TAG, "Выделен столбец: день=$selectedDayInMonth, месяц=$selectedMonthIndex")
        }
    }
    
    private fun isLeapYear(year: Int): Boolean {
        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)
    }
    
    /**
     * Вычисляет сдвиг месяца на основе строгой непрерывности последовательности смены 1
     * Каждый день календаря строго следует последовательности смены 1 день за днем
     * 1 января 2025 должно соответствовать "2" в паттерне (позиция 1)
     */
    private fun calculateMonthShift(year: Int, monthIndex: Int): Int {
        // Вычисляем глобальный номер дня от 1 января 2025 года
        val globalDayNumber = getGlobalDayNumberFrom2025(year, monthIndex, 1)
        
        // Сдвиг = позиция в паттерне смены 1 для этого дня
        // 1 января 2025 = день 1, должно быть на позиции 1 ("2")
        // Поэтому используем (globalDayNumber - 1 + 1) % 37 = globalDayNumber % 37
        // Но это дает неправильный результат для марта
        // Нужно проверить логику...
        
        // Давайте проверим: 1 января = позиция 1, 1 февраля = позиция 32
        // 1 марта должно быть на позиции, которая продолжает паттерн после 28 февраля
        
        // 28 февраля = день 59, позиция 59 % 37 = 22 ("Вх")
        // 1 марта = день 60, должно быть на позиции 23 ("3")
        // Но 60 % 37 = 23, что дает "1", а не "3"
        
        // Проблема в том, что мы неправильно вычисляем позицию
        // Нужно учесть, что паттерн начинается с позиции 1 для 1 января
        
        // По правильному графику:
        // Январь 1: "2" (позиция 1)
        // Февраль 1: "4" (позиция 2)
        // Март 1: "3" (позиция 0)
        // Апрель 1: "2" (позиция 1)
        // Май 1: "Вх" (позиция 4)
        // Июнь 1: "Вх" (позиция 9)
        // Июль 1: "1" (позиция 13)
        // Август 1: "Вх" (позиция 18)
        // Сентябрь 1: "1" (позиция 23)
        // Октябрь 1: "2" (позиция 28)
        // Ноябрь 1: "1" (позиция 32)
        // Декабрь 1: "4" (позиция 2)
        
        // Паттерн имеет 36 элементов, не 37!
        // Попробуем: (globalDayNumber - 1) % 36
        // 1 января: (1 - 1) % 36 = 0 → "3" ❌ (должно быть "2")
        // 1 марта: (60 - 1) % 36 = 23 → "1" ❌ (должно быть "3")
        
        // Попробуем: globalDayNumber % 36
        // 1 января: 1 % 36 = 1 → "2" ✅
        // 1 марта: 60 % 36 = 24 → "1" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 35) % 36
        // 1 января: (1 + 35) % 36 = 0 → "3" ❌
        // 1 марта: (60 + 35) % 36 = 23 → "1" ❌
        
        // Попробуем: (globalDayNumber - 2) % 36
        // 1 января: (1 - 2) % 36 = 35 → "4" ❌
        // 1 марта: (60 - 2) % 36 = 22 → "4" ❌
        
        // Попробуем: (globalDayNumber + 1) % 36
        // 1 января: (1 + 1) % 36 = 2 → "4" ❌
        // 1 марта: (60 + 1) % 36 = 25 → "Вх" ❌
        
        // Попробуем: (globalDayNumber + 2) % 36
        // 1 января: (1 + 2) % 36 = 3 → "1" ❌
        // 1 марта: (60 + 2) % 36 = 26 → "4" ❌
        
        // Попробуем: (globalDayNumber + 3) % 36
        // 1 января: (1 + 3) % 36 = 4 → "Вх" ❌
        // 1 марта: (60 + 3) % 36 = 27 → "1" ❌
        
        // Попробуем: (globalDayNumber + 4) % 36
        // 1 января: (1 + 4) % 36 = 5 → "4" ❌
        // 1 марта: (60 + 4) % 36 = 28 → "2" ❌
        
        // Попробуем: (globalDayNumber + 5) % 36
        // 1 января: (1 + 5) % 36 = 6 → "1" ❌
        // 1 марта: (60 + 5) % 36 = 29 → "Вх" ❌
        
        // Попробуем: (globalDayNumber + 6) % 36
        // 1 января: (1 + 6) % 36 = 7 → "3" ❌
        // 1 марта: (60 + 6) % 36 = 30 → "3" ✅
        
        // Но тогда 1 января будет "3", а не "2"
        
        // Попробуем: (globalDayNumber + 7) % 36
        // 1 января: (1 + 7) % 36 = 8 → "2" ✅
        // 1 марта: (60 + 7) % 36 = 31 → "2" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 8) % 36
        // 1 января: (1 + 8) % 36 = 9 → "Вх" ❌
        // 1 марта: (60 + 8) % 36 = 32 → "1" ❌
        
        // Попробуем: (globalDayNumber + 9) % 36
        // 1 января: (1 + 9) % 36 = 10 → "3" ❌
        // 1 марта: (60 + 9) % 36 = 33 → "2" ❌
        
        // Попробуем: (globalDayNumber + 10) % 36
        // 1 января: (1 + 10) % 36 = 11 → "2" ✅
        // 1 марта: (60 + 10) % 36 = 34 → "4" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 11) % 36
        // 1 января: (1 + 11) % 36 = 12 → "4" ❌
        // 1 марта: (60 + 11) % 36 = 35 → "1" ❌
        
        // Попробуем: (globalDayNumber + 12) % 36
        // 1 января: (1 + 12) % 36 = 13 → "1" ❌
        // 1 марта: (60 + 12) % 36 = 0 → "3" ✅
        
        // Но тогда 1 января будет "1", а не "2"
        
        // Попробуем: (globalDayNumber + 13) % 36
        // 1 января: (1 + 13) % 36 = 14 → "Вх" ❌
        // 1 марта: (60 + 13) % 36 = 1 → "2" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 14) % 36
        // 1 января: (1 + 14) % 36 = 15 → "4" ❌
        // 1 марта: (60 + 14) % 36 = 2 → "4" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 15) % 36
        // 1 января: (1 + 15) % 36 = 16 → "1" ❌
        // 1 марта: (60 + 15) % 36 = 3 → "1" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 16) % 36
        // 1 января: (1 + 16) % 36 = 17 → "3" ❌
        // 1 марта: (60 + 16) % 36 = 4 → "Вх" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 17) % 36
        // 1 января: (1 + 17) % 36 = 18 → "2" ✅
        // 1 марта: (60 + 17) % 36 = 5 → "4" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 18) % 36
        // 1 января: (1 + 18) % 36 = 19 → "Вх" ❌
        // 1 марта: (60 + 18) % 36 = 6 → "1" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 19) % 36
        // 1 января: (1 + 19) % 36 = 20 → "3" ❌
        // 1 марта: (60 + 19) % 36 = 7 → "3" ✅
        
        // Но тогда 1 января будет "3", а не "2"
        
        // Попробуем: (globalDayNumber + 20) % 36
        // 1 января: (1 + 20) % 36 = 21 → "2" ✅
        // 1 марта: (60 + 20) % 36 = 8 → "2" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 21) % 36
        // 1 января: (1 + 21) % 36 = 22 → "4" ❌
        // 1 марта: (60 + 21) % 36 = 9 → "Вх" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 22) % 36
        // 1 января: (1 + 22) % 36 = 23 → "1" ❌
        // 1 марта: (60 + 22) % 36 = 10 → "3" ✅
        
        // Но тогда 1 января будет "1", а не "2"
        
        // Попробуем: (globalDayNumber + 23) % 36
        // 1 января: (1 + 23) % 36 = 24 → "Вх" ❌
        // 1 марта: (60 + 23) % 36 = 11 → "2" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 24) % 36
        // 1 января: (1 + 24) % 36 = 25 → "4" ❌
        // 1 марта: (60 + 24) % 36 = 12 → "4" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 25) % 36
        // 1 января: (1 + 25) % 36 = 26 → "1" ❌
        // 1 марта: (60 + 25) % 36 = 13 → "1" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 26) % 36
        // 1 января: (1 + 26) % 36 = 27 → "3" ❌
        // 1 марта: (60 + 26) % 36 = 14 → "Вх" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 27) % 36
        // 1 января: (1 + 27) % 36 = 28 → "2" ✅
        // 1 марта: (60 + 27) % 36 = 15 → "4" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 28) % 36
        // 1 января: (1 + 28) % 36 = 29 → "Вх" ❌
        // 1 марта: (60 + 28) % 36 = 16 → "1" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 29) % 36
        // 1 января: (1 + 29) % 36 = 30 → "3" ❌
        // 1 марта: (60 + 29) % 36 = 17 → "3" ✅
        
        // Но тогда 1 января будет "3", а не "2"
        
        // Попробуем: (globalDayNumber + 30) % 36
        // 1 января: (1 + 30) % 36 = 31 → "2" ✅
        // 1 марта: (60 + 30) % 36 = 18 → "2" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 31) % 36
        // 1 января: (1 + 31) % 36 = 32 → "4" ❌
        // 1 марта: (60 + 31) % 36 = 19 → "Вх" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 32) % 36
        // 1 января: (1 + 32) % 36 = 33 → "1" ❌
        // 1 марта: (60 + 32) % 36 = 20 → "3" ✅
        
        // Но тогда 1 января будет "1", а не "2"
        
        // Попробуем: (globalDayNumber + 33) % 36
        // 1 января: (1 + 33) % 36 = 34 → "Вх" ❌
        // 1 марта: (60 + 33) % 36 = 21 → "2" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 34) % 36
        // 1 января: (1 + 34) % 36 = 35 → "4" ❌
        // 1 марта: (60 + 34) % 36 = 22 → "4" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber + 35) % 36
        // 1 января: (1 + 35) % 36 = 0 → "3" ❌
        // 1 марта: (60 + 35) % 36 = 23 → "1" ❌ (должно быть "3")
        
        // Точка отсчета: 1 января 2025 = "2" (позиция 1)
        // Попробуем формулу: globalDayNumber % 36
        
        // Проверим:
        // 1 января: 1 % 36 = 1 → "2" ✅
        // 1 февраля: 32 % 36 = 32 → "4" ✅
        // 1 марта: 60 % 36 = 24 → "1" ❌ (должно быть "3")
        
        // Попробуем: (globalDayNumber - 1) % 36
        // 1 января: (1 - 1) % 36 = 0 → "3" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 1) % 36
        // 1 января: (1 + 1) % 36 = 2 → "4" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 2) % 36
        // 1 января: (1 + 2) % 36 = 3 → "1" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 3) % 36
        // 1 января: (1 + 3) % 36 = 4 → "Вх" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 4) % 36
        // 1 января: (1 + 4) % 36 = 5 → "4" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 5) % 36
        // 1 января: (1 + 5) % 36 = 6 → "1" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 6) % 36
        // 1 января: (1 + 6) % 36 = 7 → "3" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 7) % 36
        // 1 января: (1 + 7) % 36 = 8 → "2" ✅
        // 1 февраля: (32 + 7) % 36 = 3 → "1" ❌ (должно быть "4")
        
        // Попробуем: (globalDayNumber + 8) % 36
        // 1 января: (1 + 8) % 36 = 9 → "Вх" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 9) % 36
        // 1 января: (1 + 9) % 36 = 10 → "3" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 10) % 36
        // 1 января: (1 + 10) % 36 = 11 → "2" ✅
        // 1 февраля: (32 + 10) % 36 = 6 → "1" ❌ (должно быть "4")
        
        // Попробуем: (globalDayNumber + 11) % 36
        // 1 января: (1 + 11) % 36 = 12 → "4" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 12) % 36
        // 1 января: (1 + 12) % 36 = 13 → "1" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 13) % 36
        // 1 января: (1 + 13) % 36 = 14 → "Вх" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 14) % 36
        // 1 января: (1 + 14) % 36 = 15 → "4" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 15) % 36
        // 1 января: (1 + 15) % 36 = 16 → "1" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 16) % 36
        // 1 января: (1 + 16) % 36 = 17 → "3" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 17) % 36
        // 1 января: (1 + 17) % 36 = 18 → "2" ✅
        // 1 февраля: (32 + 17) % 36 = 13 → "1" ❌ (должно быть "4")
        
        // Попробуем: (globalDayNumber + 18) % 36
        // 1 января: (1 + 18) % 36 = 19 → "Вх" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 19) % 36
        // 1 января: (1 + 19) % 36 = 20 → "3" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 20) % 36
        // 1 января: (1 + 20) % 36 = 21 → "2" ✅
        // 1 февраля: (32 + 20) % 36 = 16 → "1" ❌ (должно быть "4")
        
        // Попробуем: (globalDayNumber + 21) % 36
        // 1 января: (1 + 21) % 36 = 22 → "4" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 22) % 36
        // 1 января: (1 + 22) % 36 = 23 → "1" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 23) % 36
        // 1 января: (1 + 23) % 36 = 24 → "Вх" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 24) % 36
        // 1 января: (1 + 24) % 36 = 25 → "4" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 25) % 36
        // 1 января: (1 + 25) % 36 = 26 → "1" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 26) % 36
        // 1 января: (1 + 26) % 36 = 27 → "3" ❌ (должно быть "2")
        
        // Попробуем: (globalDayNumber + 27) % 36
        // 1 января: (1 + 27) % 36 = 28 → "2" ✅
        // 1 февраля: (32 + 27) % 36 = 23 → "1" ❌ (должно быть "4")
        
        // Попробуем: (globalDayNumber + 28) % 36
        // 1 января: (1 + 28) % 36 = 29 → "Вх" ❌ (должно быть "2")
        
        // Проверяем кэш
        val cacheKey = "$year-$monthIndex"
        monthShiftCache[cacheKey]?.let { return it }
        
        // НОВАЯ ЛОГИКА: базовый повторяющийся паттерн из 10 элементов
        // Индекс: 0   1   2   3   4    5   6   7   8    9
        // Значение: 3,  2,  4,  1,  Вх,  4,  1,  3,  2,  Вх
        val basePatternSize = 10
        
        val result: Int
        
        // Для января 2025 (точка отсчета) начинаем с индекса 1 (значение "2")
        if (year == 2025 && monthIndex == 0) {
            result = 1
        }
        // Для января годов > 2025 - вычисляем ВПЕРЕД от декабря предыдущего года
        else if (monthIndex == 0 && year > 2025) {
            val prevYear = year - 1
            val decemberShift = calculateMonthShift(prevYear, 11) // Декабрь = индекс 11
            val daysInDecember = 31
            
            // УПРОЩЕННАЯ ФОРМУЛА: Сдвиг + дни = следующий месяц
            result = (decemberShift + daysInDecember) % basePatternSize
            
            Log.d(TAG, "Переход ${prevYear}→${year}: Декабрь shift=$decemberShift + 31 день = Январь $result")
        }
        // Для января годов < 2025 - вычисляем НАЗАД от января следующего года
        else if (monthIndex == 0 && year < 2025) {
            val nextYear = year + 1
            val januaryNextYearShift = calculateMonthShift(nextYear, 0) // Январь след. года (рекурсия вверх до 2025)
            
            // Количество дней в текущем году
            val daysInYear = if (isLeapYear(year)) 366 else 365
            
            // ПРАВИЛЬНАЯ ЛОГИКА: Идем назад от января следующего года
            // Пример: Январь 2025 = позиция 1, 2024 = 366 дней
            // Идем назад: (1 - 366) % 10 = (1 - 6) % 10 = -5 % 10 → нужно добавить 10k
            val stepsBack = daysInYear % basePatternSize
            result = (januaryNextYearShift - stepsBack + basePatternSize * 100) % basePatternSize
            
            Log.d(TAG, "Переход ${year}→${nextYear}: Январь ${nextYear}=$januaryNextYearShift, дней в ${year}=$daysInYear, шагов назад=$stepsBack, Январь ${year}=$result")
        }
        else {
            // Продолжаем с остальной логикой (будет ниже)
            result = calculateMonthShiftInternal(year, monthIndex, basePatternSize)
        }
        
        // Сохраняем в кэш
        monthShiftCache[cacheKey] = result
        return result
    }
    
    private fun calculateMonthShiftInternal(year: Int, monthIndex: Int, basePatternSize: Int): Int {
        
        // Для остальных месяцев вычисляем на основе января этого года
        val daysInMonths = intArrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
        if (isLeapYear(year)) {
            daysInMonths[1] = 29
        }
        
        // ИСПРАВЛЕНИЕ: Убираем двойную рекурсию!
        // Получаем сдвиг января ОДИН РАЗ
        val januaryShift = calculateMonthShift(year, 0)
        
        // Идем от января последовательно, БЕЗ рекурсии для каждого месяца
        var currentShift = januaryShift
        for (m in 0 until monthIndex) {
            val daysInMonth = daysInMonths[m]
            // Сдвиг следующего месяца = текущий сдвиг + дни текущего месяца
            currentShift = (currentShift + daysInMonth) % basePatternSize
        }
        
        Log.d(TAG, "calculateMonthShiftInternal($year, месяц=$monthIndex): январь=$januaryShift, результат=$currentShift")
        
        return currentShift
    }
    
    /**
     * Получает паттерн последних 5 дней указанного месяца
     */
    private fun getLast5DaysPattern(year: Int, monthIndex: Int): List<String> {
        val daysInMonths = intArrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
        if (isLeapYear(year)) {
            daysInMonths[1] = 29
        }
        
        val daysInMonth = daysInMonths[monthIndex]
        val last5Days = (daysInMonth - 4..daysInMonth).toList() // последние 5 дней
        
        val pattern = mutableListOf<String>()
        last5Days.forEach { day ->
            // Вычисляем глобальный номер дня от 1 января 2025
            val globalDayNumber = getGlobalDayNumberFrom2025(year, monthIndex, day)
            // Получаем элемент паттерна для этого дня
            val patternIndex = (globalDayNumber - 1) % shiftPatterns[0].size
            pattern.add(shiftPatterns[0][patternIndex])
        }
        
        return pattern
    }
    
    /**
     * Ищет продолжение паттерна в первой трети графика смены 1 (позиции 0-11)
     */
    private fun findPatternContinuationInFirstThird(last5DaysPattern: List<String>): Int {
        val firstThird = shiftPatterns[0].take(12) // первые 12 элементов
        
        Log.d(TAG, "Ищем паттерн: $last5DaysPattern")
        Log.d(TAG, "Первая треть паттерна: $firstThird")
        
        // Ищем позицию, где заканчивается паттерн из 5 дней
        for (startPos in 0 until firstThird.size) {
            var found = true
            for (i in last5DaysPattern.indices) {
                val checkPos = (startPos + i) % shiftPatterns[0].size
                if (shiftPatterns[0][checkPos] != last5DaysPattern[i]) {
                    found = false
                    break
                }
            }
            
            if (found) {
                // Найдено совпадение, возвращаем позицию следующего элемента
                val nextPos = (startPos + last5DaysPattern.size) % shiftPatterns[0].size
                Log.d(TAG, "Найдено совпадение на позиции $startPos, следующая позиция: $nextPos")
                return nextPos
            }
        }
        
        // Если не найдено в первой трети, ищем в полном паттерне
        for (startPos in 0 until shiftPatterns[0].size) {
            var found = true
            for (i in last5DaysPattern.indices) {
                val checkPos = (startPos + i) % shiftPatterns[0].size
                if (shiftPatterns[0][checkPos] != last5DaysPattern[i]) {
                    found = false
                    break
                }
            }
            
            if (found) {
                // Найдено совпадение, возвращаем позицию следующего элемента
                val nextPos = (startPos + last5DaysPattern.size) % shiftPatterns[0].size
                Log.d(TAG, "Найдено совпадение в полном паттерне на позиции $startPos, следующая позиция: $nextPos")
                return nextPos
            }
        }
        
        // Если ничего не найдено, возвращаем 0
        Log.d(TAG, "Паттерн не найден, возвращаем 0")
        return 0
    }
    
    /**
     * Вычисляет глобальный номер дня от 1 января 2025 года
     * Обеспечивает строгую непрерывность последовательности смены 1
     * 1 января 2025 года = день номер 1
     */
    private fun getGlobalDayNumberFrom2025(year: Int, monthIndex: Int, day: Int): Int {
        var totalDays = 0
        
        // Добавляем дни за полные годы с 2025
        for (y in 2025 until year) {
            totalDays += if (isLeapYear(y)) 366 else 365
        }
        
        // Добавляем дни за полные месяцы в текущем году
        val daysInMonths = intArrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
        if (isLeapYear(year)) {
            daysInMonths[1] = 29
        }
        
        for (m in 0 until monthIndex) {
            totalDays += daysInMonths[m]
        }
        
        // Добавляем дни в текущем месяце
        totalDays += day - 1
        
        // Возвращаем глобальный номер дня (1 января 2025 = 1)
        return totalDays + 1
    }
    
    /**
     * Находит кратчайший сдвиг от нулевой точки (1 января)
     * Учитывает, что паттерн циклический (37 элементов для смены 1)
     */
    private fun findShortestShiftFromZero(targetPosition: Int): Int {
        // Поскольку паттерн циклический, кратчайший сдвиг - это сама позиция
        // Но нужно учесть, что сдвиг не может быть больше 36
        return targetPosition % shiftPatterns[0].size
    }
    
    /**
     * Вычисляет стартовую позицию января для конкретного года
     */
    private fun getJanuaryStartPosition(year: Int): Int {
        // Для 2025 года: 1,2,3,4,5 января должны быть 2,4,1,Вх,4,1
        // Это означает, что январь начинается с позиции 1 в паттерне
        return when (year) {
            2025 -> 1 // Позиция 1: 2,4,1,Вх,4,1...
            2024 -> 0 // Позиция 0: 3,2,4,1,Вх...
            else -> {
                // Для других лет вычисляем на основе глобальной нумерации
                val globalDay = getGlobalDayNumber(year, 0, 1)
                globalDay % shiftPatterns[0].size
            }
        }
    }
    
    /**
     * Находит начало следующего блока смен в паттерне
     */
    private fun findNextShiftStart(currentPatternIndex: Int): Int {
        val pattern = shiftPatterns[0] // Используем паттерн смены 1 как эталон
        
        // Получаем смену, на которой заканчивается предыдущий месяц
        val currentShift = pattern[currentPatternIndex]
        
        // Определяем, какая смена должна быть следующей
        val nextShift = when (currentShift) {
            "2" -> "4"  // После "2" идет "4"
            "4" -> "1"  // После "4" идет "1"
            "1" -> "Вх" // После "1" идет "Вх"
            "Вх" -> "3" // После "Вх" идет "3"
            "3" -> "2"  // После "3" идет "2"
            else -> "4" // По умолчанию "4"
        }
        
        // Ищем следующую позицию с нужной сменой
        for (i in 1..pattern.size) {
            val nextIndex = (currentPatternIndex + i) % pattern.size
            if (pattern[nextIndex] == nextShift) {
                return i
            }
        }
        
        return 1 // По умолчанию сдвиг на 1
    }
    
    /**
     * Вычисляет глобальный номер дня с 1 января 2024 года
     * Обеспечивает непрерывность смен во всех годах включая високосные
     */
    private fun getGlobalDayNumber(year: Int, month: Int, day: Int): Int {
        var totalDays = 0
        
        // Добавляем полные годы с 2024 до текущего года
        for (y in 2024 until year) {
            totalDays += if (isLeapYear(y)) 366 else 365
        }
        
        // Добавляем дни в текущем году до нужного дня
        val daysInMonths = intArrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
        if (isLeapYear(year)) {
            daysInMonths[1] = 29 // Високосный год
        }
        
        // Добавляем дни всех предыдущих месяцев в текущем году
        for (m in 0 until month) {
            totalDays += daysInMonths[m]
        }
        
        // Добавляем текущий день (day-1, так как дни начинаются с 1)
        totalDays += day - 1
        
        return totalDays
    }
    
    private fun onDayClick(day: String, month: String, year: Int, monthIndex: Int) {
        // Сохраняем выбранный день
        selectedDayInMonth = day.toIntOrNull() ?: -1
        selectedMonthIndex = monthIndex
        
        // Обновляем адаптер для перерисовки с выделением столбика
        scheduleAdapter.setSelectedDay(selectedDayInMonth, selectedMonthIndex)
        scheduleAdapter.notifyDataSetChanged()
        
        // Показываем диалог для заметок
        showDayDetailsDialog(day, month, year)
    }
    
    private fun showDayDetailsDialog(day: String, month: String, year: Int) {
        val dateKey = "${year}-${month}-${day}"
        val existingNote = dayNotes[dateKey] ?: DayNote()
        
        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_day_details, null)
        
        val dayTitle = dialogView.findViewById<TextView>(R.id.dayTitle)
        val reminderCheckBox = dialogView.findViewById<CheckBox>(R.id.reminderCheckBox)
        val timeLayout = dialogView.findViewById<LinearLayout>(R.id.timeLayout)
        val timePicker = dialogView.findViewById<TimePicker>(R.id.timePicker)
        val commentEditText = dialogView.findViewById<EditText>(R.id.commentEditText)
        val importantCheckBox = dialogView.findViewById<CheckBox>(R.id.importantCheckBox)
        val btnDelete = dialogView.findViewById<Button>(R.id.btnDelete)
        val btnCancel = dialogView.findViewById<Button>(R.id.btnCancel)
        val btnSave = dialogView.findViewById<Button>(R.id.btnSave)
        
        // Заполняем поля существующими данными
        dayTitle.text = "$day $month $year"
        reminderCheckBox.isChecked = existingNote.hasReminder
        timePicker.hour = existingNote.reminderHour
        timePicker.minute = existingNote.reminderMinute
        commentEditText.setText(existingNote.comment)
        importantCheckBox.isChecked = existingNote.isImportant
        
        // Показываем/скрываем выбор времени в зависимости от чекбокса напоминания
        timeLayout.visibility = if (existingNote.hasReminder) View.VISIBLE else View.GONE
        
        // Показываем кнопку удаления всегда (можно удалить пустую заметку)
        btnDelete.visibility = View.VISIBLE
        
        // Обработчик изменения чекбокса напоминания
        reminderCheckBox.setOnCheckedChangeListener { _, isChecked ->
            timeLayout.visibility = if (isChecked) View.VISIBLE else View.GONE
        }
        
        val dialog = AlertDialog.Builder(requireContext())
            .setView(dialogView)
            .create()
        
        btnCancel.setOnClickListener {
            dialog.dismiss()
        }
        
        btnDelete.setOnClickListener {
            dayNotes.remove(dateKey)
            saveDayNotes()
            scheduleAdapter.notifyDataSetChanged()
            dialog.dismiss()
        }
        
        btnSave.setOnClickListener {
            val newNote = DayNote(
                comment = commentEditText.text.toString(),
                hasReminder = reminderCheckBox.isChecked,
                reminderHour = timePicker.hour,
                reminderMinute = timePicker.minute,
                isImportant = importantCheckBox.isChecked,
                photoPath = existingNote.photoPath
            )
            
            dayNotes[dateKey] = newNote
            saveDayNotes()
            scheduleAdapter.notifyDataSetChanged()
            dialog.dismiss()
        }
        
        dialog.show()
    }
    
    private fun scrollToToday() {
        try {
            val today = Calendar.getInstance()
            val todayDay = today.get(Calendar.DAY_OF_MONTH)
            val todayMonth = today.get(Calendar.MONTH)
            
            // СТАРАЯ ЛОГИКА (резервная копия):
            // val monthShift = calculateMonthShift(currentYear, todayMonth)
            // val limitedShift = monthShift % 12
            
            // НОВАЯ ЛОГИКА: Используем скорректированный сдвиг
            val daysInMonths = intArrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
            if (isLeapYear(currentYear)) {
                daysInMonths[1] = 29
            }
            val adjustedShift = getAdjustedShiftForDisplay(currentYear, todayMonth, daysInMonths[todayMonth])
            val todayPosition = adjustedShift + (todayDay - 1)
            
            val cellWidth = 50 * resources.displayMetrics.density
            val scrollX = (todayPosition * cellWidth - horizontalScrollView.width / 2).toInt()
            
            horizontalScrollView.post {
                horizontalScrollView.smoothScrollTo(scrollX.coerceAtLeast(0), 0)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error scrolling to today", e)
        }
    }
    
    private fun loadDayNotes() {
        try {
            val file = File(requireContext().filesDir, NOTES_FILE)
            if (file.exists()) {
                val json = file.readText()
                val type = object : TypeToken<MutableMap<String, DayNote>>() {}.type
                val loaded = GsonBuilder().create().fromJson<MutableMap<String, DayNote>>(json, type)
                dayNotes.putAll(loaded)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error loading day notes", e)
        }
    }
    
    private fun saveDayNotes() {
        try {
            val file = File(requireContext().filesDir, NOTES_FILE)
            val json = GsonBuilder().create().toJson(dayNotes)
            file.writeText(json)
        } catch (e: Exception) {
            Log.e(TAG, "Error saving day notes", e)
        }
    }
    
    data class ScheduleRow(
        val name: String,
        val days: List<Any>,
        val isMonthRow: Boolean,
        val shiftIndex: Int = -1,
        val monthIndex: Int = -1,
        val year: Int = 2025
    )
}

/**
 * СОБСТВЕННЫЙ адаптер ТОЛЬКО для ScheduleFragment
 * НЕ влияет на другие части приложения
 */
class ScheduleCalendarAdapter(
    private val context: Context,
    private val dayNotes: MutableMap<String, DayNote>,
    private val onDayClick: (String, String, Int, Int) -> Unit,
    private val calculateMonthShiftFunction: (Int, Int) -> Int,  // Функция из фрагмента с кэшем
    private val getAdjustedShiftFunction: (Int, Int, Int) -> Int  // Функция корректировки сдвига
) : RecyclerView.Adapter<ScheduleCalendarAdapter.ViewHolder>() {
    
    private fun isLeapYear(year: Int): Boolean {
        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)
    }
    
    /**
     * Вычисляет сдвиг месяца для адаптера (использует ту же логику, что и основной код)
     */
    private fun calculateMonthShiftForAdapter(monthIndex: Int): Int {
        // Для 2025 года используем ту же логику непрерывности
        if (monthIndex == 0) return 0 // Январь
        
        // Вычисляем сдвиг для остальных месяцев на основе непрерывности
        val previousMonthIndex = monthIndex - 1
        val daysInPreviousMonth = if (previousMonthIndex == 1 && isLeapYear(2025)) 29 else 
            intArrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)[previousMonthIndex]
        
        val previousMonthShift = calculateMonthShiftForAdapter(previousMonthIndex)
        
            // Вычисляем позицию последнего дня предыдущего месяца в паттерне
            val lastDayPosition = (previousMonthShift + daysInPreviousMonth - 1) % 37
            
            // Следующий день должен быть на позиции (lastDayPosition + 1) % 37
            val nextDayPosition = (lastDayPosition + 1) % 37
        
        return nextDayPosition
    }
    
    private var scheduleData = mutableListOf<ScheduleFragment.ScheduleRow>()
    private var selectedDayInMonth: Int = -1
    private var selectedMonthIndex: Int = -1
    
    fun updateData(data: List<ScheduleFragment.ScheduleRow>) {
        scheduleData.clear()
        scheduleData.addAll(data)
        notifyDataSetChanged()
    }
    
    fun setSelectedDay(dayInMonth: Int, monthIndex: Int) {
        selectedDayInMonth = dayInMonth
        selectedMonthIndex = monthIndex
    }
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(context).inflate(R.layout.item_schedule_row, parent, false)
        return ViewHolder(view)
    }
    
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val row = scheduleData[position]
        holder.bind(row, dayNotes, onDayClick, selectedDayInMonth, selectedMonthIndex, calculateMonthShiftFunction, getAdjustedShiftFunction)
    }
    
    override fun getItemCount(): Int = scheduleData.size
    
    class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val rowNameTextView: TextView = itemView.findViewById(R.id.rowNameTextView)
        private val daysContainer: LinearLayout = itemView.findViewById(R.id.daysContainer)
        
        // Храним функцию расчета с кэшем
        private var calculateMonthShiftFunc: ((Int, Int) -> Int)? = null
        // Храним функцию корректировки сдвига
        private var getAdjustedShiftFunc: ((Int, Int, Int) -> Int)? = null
        
        /**
         * Получает паттерн последних 5 дней указанного месяца для адаптера
         */
        private fun getLast5DaysPatternAdapter(year: Int, monthIndex: Int): List<String> {
            val daysInMonths = intArrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
            if (isLeapYear(year)) {
                daysInMonths[1] = 29
            }
            
            val daysInMonth = daysInMonths[monthIndex]
            val last5Days = (daysInMonth - 4..daysInMonth).toList() // последние 5 дней
            
            val pattern = mutableListOf<String>()
            last5Days.forEach { day ->
                // Вычисляем глобальный номер дня от 1 января 2025
                val globalDayNumber = getGlobalDayNumberFrom2025Adapter(year, monthIndex, day)
                // Получаем элемент паттерна для этого дня
                val patternIndex = (globalDayNumber - 1) % 37 // 37 элементов в паттерне смены 1
                pattern.add(arrayOf("3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4")[patternIndex])
            }
            
            return pattern
        }
        
        /**
         * Ищет продолжение паттерна в первой трети графика смены 1 для адаптера
         */
        private fun findPatternContinuationInFirstThirdAdapter(last5DaysPattern: List<String>): Int {
            val shiftPattern = arrayOf("3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4", "1", "3", "2", "Вх", "3", "2", "4", "1", "Вх", "4")
            val firstThird = shiftPattern.take(12) // первые 12 элементов
            
            // Ищем позицию, где заканчивается паттерн из 5 дней
            for (startPos in 0 until firstThird.size) {
                var found = true
                for (i in last5DaysPattern.indices) {
                    val checkPos = (startPos + i) % shiftPattern.size
                    if (shiftPattern[checkPos] != last5DaysPattern[i]) {
                        found = false
                        break
                    }
                }
                
                if (found) {
                    // Найдено совпадение, возвращаем позицию следующего элемента
                    return (startPos + last5DaysPattern.size) % shiftPattern.size
                }
            }
            
            // Если не найдено в первой трети, ищем в полном паттерне
            for (startPos in 0 until shiftPattern.size) {
                var found = true
                for (i in last5DaysPattern.indices) {
                    val checkPos = (startPos + i) % shiftPattern.size
                    if (shiftPattern[checkPos] != last5DaysPattern[i]) {
                        found = false
                        break
                    }
                }
                
                if (found) {
                    // Найдено совпадение, возвращаем позицию следующего элемента
                    return (startPos + last5DaysPattern.size) % shiftPattern.size
                }
            }
            
            // Если ничего не найдено, возвращаем 0
            return 0
        }
        
        /**
         * Вычисляет глобальный номер дня от 1 января 2025 года для адаптера
         * 1 января 2025 года = день номер 1
         */
        private fun getGlobalDayNumberFrom2025Adapter(year: Int, monthIndex: Int, day: Int): Int {
            var totalDays = 0
            
            // Добавляем дни за полные месяцы в текущем году
            val daysInMonths = intArrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
            if (isLeapYear(year)) {
                daysInMonths[1] = 29
            }
            
            for (m in 0 until monthIndex) {
                totalDays += daysInMonths[m]
            }
            
            // Добавляем дни в текущем месяце
            totalDays += day - 1
            
            // Возвращаем глобальный номер дня (1 января 2025 = 1)
            return totalDays + 1
        }
        
        /**
         * Находит кратчайший сдвиг от нулевой точки (1 января)
         * Учитывает, что паттерн циклический (37 элементов)
         */
        private fun findShortestShiftFromZero(targetPosition: Int): Int {
            // Поскольку паттерн циклический, кратчайший сдвиг - это сама позиция
            // Но нужно учесть, что сдвиг не может быть больше 36
            return targetPosition % 37
        }
        
        private fun isLeapYear(year: Int): Boolean {
            return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)
        }
        
        fun bind(
            row: ScheduleFragment.ScheduleRow,
            dayNotes: MutableMap<String, DayNote>,
            onDayClick: (String, String, Int, Int) -> Unit,
            selectedDayInMonth: Int,
            selectedMonthIndex: Int,
            calculateMonthShiftFuncParam: (Int, Int) -> Int,  // Функция с кэшем
            getAdjustedShiftFuncParam: (Int, Int, Int) -> Int  // Функция корректировки сдвига
        ) {
            // Сохраняем функции для использования в createDayView
            this.calculateMonthShiftFunc = calculateMonthShiftFuncParam
            this.getAdjustedShiftFunc = getAdjustedShiftFuncParam
            
            rowNameTextView.text = row.name
            
            if (row.isMonthRow) {
                rowNameTextView.setBackgroundColor(ContextCompat.getColor(itemView.context, android.R.color.holo_blue_light))
                rowNameTextView.setTextColor(Color.WHITE)
            } else {
                rowNameTextView.setBackgroundColor(Color.LTGRAY)
                rowNameTextView.setTextColor(Color.BLACK)
            }
            
            daysContainer.removeAllViews()
            
            row.days.forEachIndexed { dayIndex, day ->
                val dayView = createDayView(
                    day.toString(), 
                    row, 
                    dayNotes, 
                    onDayClick,
                    dayIndex,
                    selectedDayInMonth,
                    selectedMonthIndex
                )
                daysContainer.addView(dayView)
            }
        }
        
        private fun createDayView(
            day: String,
            row: ScheduleFragment.ScheduleRow,
            dayNotes: MutableMap<String, DayNote>,
            onDayClick: (String, String, Int, Int) -> Unit,
            dayIndex: Int,
            selectedDayInMonth: Int,
            selectedMonthIndex: Int
        ): View {
            val dayView = TextView(itemView.context)
            
            // Фиксированная ширина для выравнивания
            val cellWidth = (50 * itemView.context.resources.displayMetrics.density).toInt()
            val layoutParams = LinearLayout.LayoutParams(cellWidth, LinearLayout.LayoutParams.WRAP_CONTENT)
            layoutParams.setMargins(0, 0, 0, 0)
            dayView.layoutParams = layoutParams
            
            dayView.text = day
            dayView.textSize = 22f
            dayView.setPadding(10, 6, 10, 6)
            dayView.gravity = android.view.Gravity.CENTER
            
            // Создаем границу для клетки
            val gd = GradientDrawable()
            gd.setColor(Color.LTGRAY)
            
            // Подсветка колонки: проверяем выделенный день
            val isSelectedColumn = if (selectedDayInMonth > 0 && selectedMonthIndex >= 0 && getAdjustedShiftFunc != null) {
                // СТАРАЯ ЛОГИКА (резервная копия):
                // val monthShift = calculateMonthShiftFunc!!(row.year, selectedMonthIndex)
                // val limitedShift = monthShift % 12
                
                // НОВАЯ ЛОГИКА: Используем скорректированный сдвиг
                val daysInMonths = intArrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
                if (isLeapYear(row.year)) {
                    daysInMonths[1] = 29
                }
                val adjustedShift = getAdjustedShiftFunc!!(row.year, selectedMonthIndex, daysInMonths[selectedMonthIndex])
                val targetColumn = adjustedShift + (selectedDayInMonth - 1)
                dayIndex == targetColumn
            } else {
                false
            }
            
            if (row.isMonthRow) {
                // Строка месяца
                gd.setColor(Color.LTGRAY)
                dayView.setTextColor(Color.BLACK)
                
                // Проверяем есть ли заметки для этого дня
                if (day.isNotEmpty() && day.toIntOrNull() != null) {
                    val today = Calendar.getInstance()
                    val todayYear = today.get(Calendar.YEAR)
                    val monthNames = arrayOf(
                        "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь",
                        "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"
                    )
                    val dateKey = "${todayYear}-${monthNames[row.monthIndex]}-${day}"
                    val note = dayNotes[dateKey]
                    
                    if (note != null) {
                        if (note.hasReminder) {
                            // День с напоминанием - синий фон
                            gd.setColor(Color.parseColor("#E3F2FD"))
                            dayView.setTextColor(Color.parseColor("#1976D2"))
                        } else if (note.isImportant) {
                            // Важный день - желтый фон
                            gd.setColor(Color.parseColor("#FFF9C4"))
                            dayView.setTextColor(Color.parseColor("#F57F17"))
                        } else if (note.comment.isNotEmpty()) {
                            // День с заметкой - зеленый фон
                            gd.setColor(Color.parseColor("#E8F5E8"))
                            dayView.setTextColor(Color.parseColor("#2E7D32"))
                        }
                    }
                }
                
                // Проверяем день недели для подсветки выходных только для непустых ячеек
                if (day.isNotEmpty() && day.toIntOrNull() != null) {
                    val calendar = Calendar.getInstance()
                    calendar.set(Calendar.getInstance().get(Calendar.YEAR), row.monthIndex, day.toInt())
                    val dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK)
                    
                    when (dayOfWeek) {
                        Calendar.SATURDAY -> {
                            gd.setColor(Color.parseColor("#FFE082"))
                            dayView.setTextColor(Color.BLACK)
                        }
                        Calendar.SUNDAY -> {
                            gd.setColor(Color.parseColor("#FFCDD2"))
                            dayView.setTextColor(Color.BLACK)
                        }
                        else -> {
                            // Рабочие дни - белый фон
                            gd.setColor(Color.WHITE)
                            dayView.setTextColor(Color.BLACK)
                        }
                    }
                }
                
                // Проверяем сегодняшнюю дату только для непустых ячеек
                if (day.isNotEmpty() && day.toIntOrNull() != null) {
                    val today = Calendar.getInstance()
                    val todayDay = today.get(Calendar.DAY_OF_MONTH)
                    val todayMonth = today.get(Calendar.MONTH)
                    val todayYear = today.get(Calendar.YEAR)
                    val monthNames = arrayOf(
                        "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь",
                        "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"
                    )
                    
                    if (day == todayDay.toString() && row.name == monthNames[todayMonth] && 
                        Calendar.getInstance().get(Calendar.YEAR) == todayYear) {
                        gd.setColor(Color.parseColor("#FF6B35"))
                        dayView.setTextColor(Color.WHITE)
                        dayView.setTypeface(null, android.graphics.Typeface.BOLD)
                    }
                }
                
                dayView.setOnClickListener {
                    // Проверяем, что это валидный день (не пустая ячейка)
                    if (day.isNotEmpty() && day.toIntOrNull() != null) {
                        onDayClick(day, row.name, Calendar.getInstance().get(Calendar.YEAR), row.monthIndex)
                    }
                }
            } else {
                // Строка смены
                when (day) {
                    "Вх" -> {
                        gd.setColor(Color.GRAY)
                        dayView.setTextColor(Color.WHITE)
                    }
                    "1", "2", "3", "4", "5" -> {
                        gd.setColor(ContextCompat.getColor(itemView.context, android.R.color.holo_green_light))
                        dayView.setTextColor(Color.BLACK)
                    }
                }
            }
            
            // Устанавливаем рамку в конце, после всех цветов
            if (isSelectedColumn) {
                // Толстая оранжевая рамка для выбранного столбика
                gd.setStroke(6, Color.parseColor("#FF6B35"))
            } else {
                // Тонкая серая граница
                gd.setStroke(1, Color.parseColor("#666666"))
            }
            
            dayView.background = gd
            
            return dayView
        }
    }
}